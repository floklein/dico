import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import {
  generateRoundWord,
  normalizeAndFillDefinitions,
  type DefinitionBatchInput,
  type DefinitionBatchOutput,
} from "@/lib/game/ai";
import { RoomManager } from "@/lib/game/store";
import type { SessionPayload } from "@/lib/game/types";

vi.mock("@/lib/game/ai", () => ({
  generateRoundWord: vi.fn(),
  normalizeAndFillDefinitions: vi.fn(),
}));

const mockedGenerateRoundWord = vi.mocked(generateRoundWord);
const mockedNormalizeAndFillDefinitions = vi.mocked(normalizeAndFillDefinitions);

interface StartedRoom {
  manager: RoomManager;
  roomCode: string;
  hostSession: SessionPayload;
  aliceSession: SessionPayload;
  bobSession: SessionPayload;
}

async function createStartedRoom(): Promise<StartedRoom> {
  const manager = new RoomManager();
  const created = manager.createRoom("Host");
  const roomCode = created.roomCode;
  const hostSession = created.session;
  const aliceSession = manager.joinRoom(roomCode, "Alice").session;
  const bobSession = manager.joinRoom(roomCode, "Bob").session;
  await manager.startGame(roomCode, hostSession);

  return {
    manager,
    roomCode,
    hostSession,
    aliceSession,
    bobSession,
  };
}

async function flushAsyncWork(): Promise<void> {
  await Promise.resolve();
  await Promise.resolve();
}

function getCorrectOptionId(roundNumber: number): string {
  return `correct-${roundNumber}`;
}

function getPlayerOptionId(roundNumber: number, playerId: string): string {
  return `player-${roundNumber}-${playerId}`;
}

beforeEach(() => {
  vi.useFakeTimers();

  mockedGenerateRoundWord.mockResolvedValue({
    word: "Hypallage",
    correctDefinition: "On donne à un mot une qualité qui va normalement à un autre",
  });

  mockedNormalizeAndFillDefinitions.mockImplementation(
    async (
      _word: string,
      _correctDefinition: string,
      entries: DefinitionBatchInput[],
    ): Promise<DefinitionBatchOutput[]> =>
      entries.map((entry) => ({
        playerId: entry.playerId,
        correctedText: entry.rawDefinition?.trim() || `Auto ${entry.name}`,
        isAutoGenerated: !entry.rawDefinition?.trim(),
      })),
  );
});

afterEach(() => {
  vi.useRealTimers();
});

describe("RoomManager leave flow", () => {
  it("transitions from WRITING to VOTING when remaining players already submitted", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");

    const leaveSnapshot = manager.leaveRoom(roomCode, bobSession);
    expect(leaveSnapshot?.phase).toBe("WRITING");

    await flushAsyncWork();

    const afterSnapshot = manager.getSnapshot(roomCode, hostSession.playerId);
    expect(afterSnapshot.phase).toBe("VOTING");
    expect(afterSnapshot.players).toHaveLength(2);
    expect(afterSnapshot.round?.submittedCount).toBe(2);
    expect(afterSnapshot.round?.options).toHaveLength(3);
  });

  it("drops a leaving player's definition from submitted count", async () => {
    const { manager, roomCode, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, bobSession, "Definition bob");

    const leaveSnapshot = manager.leaveRoom(roomCode, bobSession);
    expect(leaveSnapshot?.phase).toBe("WRITING");
    expect(leaveSnapshot?.players).toHaveLength(2);
    expect(leaveSnapshot?.round?.submittedCount).toBe(0);
  });

  it("transitions from VOTING to ROUND_RESULTS when remaining players already voted", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");
    const votingSnapshot = await manager.submitDefinition(roomCode, bobSession, "Definition bob");

    expect(votingSnapshot.phase).toBe("VOTING");
    const roundNumber = votingSnapshot.round?.roundNumber;
    expect(roundNumber).toBeTruthy();
    const selectedOptionId = getCorrectOptionId(roundNumber as number);

    manager.vote(roomCode, hostSession, selectedOptionId);
    manager.vote(roomCode, aliceSession, selectedOptionId);

    const leaveSnapshot = manager.leaveRoom(roomCode, bobSession);
    expect(leaveSnapshot?.phase).toBe("ROUND_RESULTS");
    expect(leaveSnapshot?.players).toHaveLength(2);
    expect(leaveSnapshot?.round?.votedCount).toBe(2);
    expect(leaveSnapshot?.round?.roundScoreDeltaByPlayerId?.[bobSession.playerId]).toBeUndefined();
  });

  it("drops a leaving player's vote from voted count", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");
    const votingSnapshot = await manager.submitDefinition(roomCode, bobSession, "Definition bob");
    const roundNumber = votingSnapshot.round?.roundNumber;
    expect(roundNumber).toBeTruthy();
    const selectedOptionId = getCorrectOptionId(roundNumber as number);

    manager.vote(roomCode, hostSession, selectedOptionId);
    manager.vote(roomCode, bobSession, selectedOptionId);

    const leaveSnapshot = manager.leaveRoom(roomCode, bobSession);
    expect(leaveSnapshot?.phase).toBe("VOTING");
    expect(leaveSnapshot?.players).toHaveLength(2);
    expect(leaveSnapshot?.round?.votedCount).toBe(1);
  });

  it("rejects voting for your own definition", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");
    const votingSnapshot = await manager.submitDefinition(roomCode, bobSession, "Definition bob");
    const roundNumber = votingSnapshot.round?.roundNumber;
    expect(roundNumber).toBeTruthy();

    const ownOptionId = getPlayerOptionId(roundNumber as number, hostSession.playerId);

    expect(() => manager.vote(roomCode, hostSession, ownOptionId)).toThrow(
      "Vous ne pouvez pas voter pour votre propre définition.",
    );

    const afterSnapshot = manager.getSnapshot(roomCode, hostSession.playerId);
    expect(afterSnapshot.round?.votedCount).toBe(0);
    expect(afterSnapshot.round?.votedOptionId).toBeNull();
  });
});

describe("RoomManager AI error state", () => {
  it("switches to ERROR when round word generation fails", async () => {
    const manager = new RoomManager();
    const created = manager.createRoom("Host");
    const roomCode = created.roomCode;
    const hostSession = created.session;

    manager.joinRoom(roomCode, "Alice");
    mockedGenerateRoundWord.mockRejectedValueOnce(new Error("provider down"));

    const snapshot = await manager.startGame(roomCode, hostSession);

    expect(snapshot.phase).toBe("ERROR");
    expect(snapshot.errorMessage).toContain("Erreur IA pendant la génération du mot de manche.");
    expect(snapshot.errorMessage).toContain("provider down");
  });

  it("switches to ERROR when definition normalization fails", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();
    mockedNormalizeAndFillDefinitions.mockRejectedValueOnce(new Error("normalization failed"));

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");
    const snapshot = await manager.submitDefinition(roomCode, bobSession, "Definition bob");

    expect(snapshot.phase).toBe("ERROR");
    expect(snapshot.errorMessage).toContain("Erreur IA pendant la normalisation des définitions.");
    expect(snapshot.errorMessage).toContain("normalization failed");
  });
});

describe("RoomManager final round flow", () => {
  it("keeps last round in ROUND_RESULTS before transitioning to FINAL_RESULTS on nextRound", async () => {
    const manager = new RoomManager();
    const created = manager.createRoom("Host");
    const roomCode = created.roomCode;
    const hostSession = created.session;
    const aliceSession = manager.joinRoom(roomCode, "Alice").session;

    await manager.startGame(roomCode, hostSession);

    for (let roundIndex = 1; roundIndex <= 5; roundIndex += 1) {
      await manager.submitDefinition(roomCode, hostSession, `Host def ${roundIndex}`);
      const votingSnapshot = await manager.submitDefinition(
        roomCode,
        aliceSession,
        `Alice def ${roundIndex}`,
      );

      expect(votingSnapshot.phase).toBe("VOTING");
      const roundNumber = votingSnapshot.round?.roundNumber;
      expect(roundNumber).toBeTruthy();
      const optionId = getCorrectOptionId(roundNumber as number);

      manager.vote(roomCode, hostSession, optionId);
      const roundResultsSnapshot = manager.vote(roomCode, aliceSession, optionId);

      expect(roundResultsSnapshot.phase).toBe("ROUND_RESULTS");
      expect(roundResultsSnapshot.round?.roundNumber).toBe(roundIndex);

      if (roundIndex < 5) {
        const nextSnapshot = await manager.nextRound(roomCode, hostSession);
        expect(nextSnapshot.phase).toBe("WRITING");
        expect(nextSnapshot.round?.roundNumber).toBe(roundIndex + 1);
      }
    }

    const beforeFinal = manager.getSnapshot(roomCode, hostSession.playerId);
    expect(beforeFinal.phase).toBe("ROUND_RESULTS");
    expect(beforeFinal.round?.roundNumber).toBe(5);

    const finalSnapshot = await manager.nextRound(roomCode, hostSession);
    expect(finalSnapshot.phase).toBe("FINAL_RESULTS");
    expect(finalSnapshot.round?.roundNumber).toBe(5);
  });
});
