import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import {
  generateRoundWord,
  normalizeAndFillDefinitions,
  type DefinitionBatchInput,
  type DefinitionBatchOutput,
} from "@/lib/game/ai";
import { RoomManager } from "@/lib/game/store";
import type { SessionPayload } from "@/lib/game/types";

vi.mock("@/lib/game/ai", () => ({
  generateRoundWord: vi.fn(),
  normalizeAndFillDefinitions: vi.fn(),
}));

const mockedGenerateRoundWord = vi.mocked(generateRoundWord);
const mockedNormalizeAndFillDefinitions = vi.mocked(normalizeAndFillDefinitions);

interface StartedRoom {
  manager: RoomManager;
  roomCode: string;
  hostSession: SessionPayload;
  aliceSession: SessionPayload;
  bobSession: SessionPayload;
}

async function createStartedRoom(): Promise<StartedRoom> {
  const manager = new RoomManager();
  const created = manager.createRoom("Host");
  const roomCode = created.roomCode;
  const hostSession = created.session;
  const aliceSession = manager.joinRoom(roomCode, "Alice").session;
  const bobSession = manager.joinRoom(roomCode, "Bob").session;
  await manager.startGame(roomCode, hostSession);

  return {
    manager,
    roomCode,
    hostSession,
    aliceSession,
    bobSession,
  };
}

async function flushAsyncWork(): Promise<void> {
  await Promise.resolve();
  await Promise.resolve();
}

beforeEach(() => {
  vi.useFakeTimers();

  mockedGenerateRoundWord.mockResolvedValue({
    word: "Hypallage",
    correctDefinition: "On donne a un mot une qualite qui va normalement a un autre",
  });

  mockedNormalizeAndFillDefinitions.mockImplementation(
    async (
      _word: string,
      _correctDefinition: string,
      entries: DefinitionBatchInput[],
    ): Promise<DefinitionBatchOutput[]> =>
      entries.map((entry) => ({
        playerId: entry.playerId,
        correctedText: entry.rawDefinition?.trim() || `Auto ${entry.name}`,
        isAutoGenerated: !entry.rawDefinition?.trim(),
      })),
  );
});

afterEach(() => {
  vi.useRealTimers();
});

describe("RoomManager leave flow", () => {
  it("transitions from WRITING to VOTING when remaining players already submitted", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");

    const leaveSnapshot = manager.leaveRoom(roomCode, bobSession);
    expect(leaveSnapshot?.phase).toBe("WRITING");

    await flushAsyncWork();

    const afterSnapshot = manager.getSnapshot(roomCode, hostSession.playerId);
    expect(afterSnapshot.phase).toBe("VOTING");
    expect(afterSnapshot.players).toHaveLength(2);
    expect(afterSnapshot.round?.submittedCount).toBe(2);
    expect(afterSnapshot.round?.options).toHaveLength(3);
  });

  it("drops a leaving player's definition from submitted count", async () => {
    const { manager, roomCode, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, bobSession, "Definition bob");

    const leaveSnapshot = manager.leaveRoom(roomCode, bobSession);
    expect(leaveSnapshot?.phase).toBe("WRITING");
    expect(leaveSnapshot?.players).toHaveLength(2);
    expect(leaveSnapshot?.round?.submittedCount).toBe(0);
  });

  it("transitions from VOTING to ROUND_RESULTS when remaining players already voted", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");
    const votingSnapshot = await manager.submitDefinition(roomCode, bobSession, "Definition bob");

    expect(votingSnapshot.phase).toBe("VOTING");
    const selectedOptionId = votingSnapshot.round?.options[0]?.id;
    expect(selectedOptionId).toBeTruthy();

    manager.vote(roomCode, hostSession, selectedOptionId as string);
    manager.vote(roomCode, aliceSession, selectedOptionId as string);

    const leaveSnapshot = manager.leaveRoom(roomCode, bobSession);
    expect(leaveSnapshot?.phase).toBe("ROUND_RESULTS");
    expect(leaveSnapshot?.players).toHaveLength(2);
    expect(leaveSnapshot?.round?.votedCount).toBe(2);
    expect(leaveSnapshot?.round?.roundScoreDeltaByPlayerId?.[bobSession.playerId]).toBeUndefined();
  });

  it("drops a leaving player's vote from voted count", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");
    const votingSnapshot = await manager.submitDefinition(roomCode, bobSession, "Definition bob");
    const selectedOptionId = votingSnapshot.round?.options[0]?.id as string;

    manager.vote(roomCode, hostSession, selectedOptionId);
    manager.vote(roomCode, bobSession, selectedOptionId);

    const leaveSnapshot = manager.leaveRoom(roomCode, bobSession);
    expect(leaveSnapshot?.phase).toBe("VOTING");
    expect(leaveSnapshot?.players).toHaveLength(2);
    expect(leaveSnapshot?.round?.votedCount).toBe(1);
  });
});

describe("RoomManager AI error state", () => {
  it("switches to ERROR when round word generation fails", async () => {
    const manager = new RoomManager();
    const created = manager.createRoom("Host");
    const roomCode = created.roomCode;
    const hostSession = created.session;

    manager.joinRoom(roomCode, "Alice");
    mockedGenerateRoundWord.mockRejectedValueOnce(new Error("provider down"));

    const snapshot = await manager.startGame(roomCode, hostSession);

    expect(snapshot.phase).toBe("ERROR");
    expect(snapshot.errorMessage).toContain("Erreur IA pendant la génération du mot de manche.");
    expect(snapshot.errorMessage).toContain("provider down");
  });

  it("switches to ERROR when definition normalization fails", async () => {
    const { manager, roomCode, hostSession, aliceSession, bobSession } = await createStartedRoom();
    mockedNormalizeAndFillDefinitions.mockRejectedValueOnce(new Error("normalization failed"));

    await manager.submitDefinition(roomCode, hostSession, "Definition host");
    await manager.submitDefinition(roomCode, aliceSession, "Definition alice");
    const snapshot = await manager.submitDefinition(roomCode, bobSession, "Definition bob");

    expect(snapshot.phase).toBe("ERROR");
    expect(snapshot.errorMessage).toContain("Erreur IA pendant la normalisation des définitions.");
    expect(snapshot.errorMessage).toContain("normalization failed");
  });
});
