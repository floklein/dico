import {
  cleanTextBasic,
  ratioOfChangedTokens,
  tokenizeAlphaNumeric,
} from "@/lib/game/helpers";

const AI_GATEWAY_URL = "https://ai-gateway.vercel.sh/v1/chat/completions";
const DEFAULT_MODEL = "google/gemini-3-flash";

interface ChatCompletionResponse {
  choices?: Array<{
    message?: {
      content?: string;
    };
  }>;
}

export interface GeneratedRoundWord {
  word: string;
  correctDefinition: string;
}

export interface DefinitionBatchInput {
  playerId: string;
  name: string;
  rawDefinition?: string;
}

export interface DefinitionBatchOutput {
  playerId: string;
  correctedText: string;
  isAutoGenerated: boolean;
}

function getGatewayKey(): string | undefined {
  return process.env.VERCEL_AI_GATEWAY_API_KEY?.trim();
}

function getModelName(): string {
  return process.env.LLM_MODEL?.trim() || DEFAULT_MODEL;
}

function extractJsonText(content: string): string {
  const trimmed = content.trim();
  if (trimmed.startsWith("{")) {
    return trimmed;
  }

  const firstBrace = trimmed.indexOf("{");
  const lastBrace = trimmed.lastIndexOf("}");
  if (firstBrace === -1 || lastBrace === -1 || lastBrace <= firstBrace) {
    throw new Error("Réponse IA non JSON.");
  }

  return trimmed.slice(firstBrace, lastBrace + 1);
}

async function callGatewayJson<T>(
  systemPrompt: string,
  userPrompt: string,
): Promise<T> {
  const key = getGatewayKey();
  if (!key) {
    throw new Error("Clé VERCEL_AI_GATEWAY_API_KEY manquante.");
  }

  const response = await fetch(AI_GATEWAY_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${key}`,
    },
    body: JSON.stringify({
      model: getModelName(),
      temperature: 0.2,
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      response_format: { type: "json_object" },
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Erreur IA (${response.status}): ${errorText}`);
  }

  const body = (await response.json()) as ChatCompletionResponse;
  const content = body.choices?.[0]?.message?.content;
  if (!content) {
    throw new Error("Réponse IA vide.");
  }

  return JSON.parse(extractJsonText(content)) as T;
}

function fallbackGeneratedWord(index: number): GeneratedRoundWord {
  const entries: GeneratedRoundWord[] = [
    {
      word: "Épenthèse",
      correctDefinition:
        "Ajout d'un son ou d'une lettre à l'intérieur d'un mot pour faciliter la prononciation.",
    },
    {
      word: "Hypallage",
      correctDefinition:
        "Figure de style qui attribue à un mot ce qui conviendrait logiquement à un autre.",
    },
    {
      word: "Logorrhée",
      correctDefinition:
        "Flux de parole abondant, rapide et souvent difficile à interrompre.",
    },
    {
      word: "Prolepse",
      correctDefinition:
        "Figure consistant à anticiper un événement futur comme s'il était déjà réalisé.",
    },
    {
      word: "Sérendipité",
      correctDefinition:
        "Fait de découvrir quelque chose d'utile ou précieux de manière inattendue.",
    },
  ];

  return entries[index % entries.length];
}

export async function generateRoundWord(roundIndex: number): Promise<GeneratedRoundWord> {
  try {
    const json = await callGatewayJson<{ word: string; correctDefinition: string }>(
      [
        "Tu es lexicographe français.",
        "Tu dois fournir un mot français très difficile mais authentique et sa définition correcte.",
        "Réponds strictement en JSON: {\"word\": string, \"correctDefinition\": string}.",
        "La définition doit faire une seule phrase concise en français.",
      ].join(" "),
      "Donne un seul mot difficile inédit (évite de répéter les mots les plus connus) et sa définition correcte.",
    );

    const word = cleanTextBasic(String(json.word ?? ""));
    const correctDefinition = cleanTextBasic(String(json.correctDefinition ?? ""));

    if (!word || !correctDefinition) {
      throw new Error("Sortie IA invalide pour le mot.");
    }

    return { word, correctDefinition };
  } catch {
    return fallbackGeneratedWord(roundIndex);
  }
}

function fallbackAutoDefinition(word: string, name: string): string {
  const lowerWord = word.toLocaleLowerCase("fr-FR");
  const templates = [
    `${lowerWord} est un terme ancien employé dans certains écrits savants.`,
    `${lowerWord} désigne une notion technique peu fréquente en français classique.`,
    `${lowerWord} correspond à un usage rare observé dans la littérature érudite.`,
    `${lowerWord} qualifie une idée spécifique dans un registre soutenu.`,
  ];

  const index = Math.abs((name.length + lowerWord.length) % templates.length);
  return cleanTextBasic(templates[index]);
}

function editDistance(a: string, b: string): number {
  const rows = a.length + 1;
  const cols = b.length + 1;
  const table: number[][] = Array.from({ length: rows }, (_, rowIndex) =>
    Array.from({ length: cols }, (_, colIndex) =>
      rowIndex === 0 ? colIndex : colIndex === 0 ? rowIndex : 0,
    ),
  );

  for (let row = 1; row < rows; row += 1) {
    for (let col = 1; col < cols; col += 1) {
      const cost = a[row - 1] === b[col - 1] ? 0 : 1;
      table[row][col] = Math.min(
        table[row - 1][col] + 1,
        table[row][col - 1] + 1,
        table[row - 1][col - 1] + cost,
      );
    }
  }

  return table[rows - 1][cols - 1];
}

function isTokenCorrectionLike(originalToken: string, correctedToken: string): boolean {
  if (originalToken === correctedToken) {
    return true;
  }

  const distance = editDistance(originalToken, correctedToken);
  const maxAllowed = Math.max(2, Math.floor(originalToken.length * 0.34));
  return distance <= maxAllowed;
}

function keepOriginalOrderAndCount(original: string, corrected: string): boolean {
  const originalTokens = tokenizeAlphaNumeric(original);
  const correctedTokens = tokenizeAlphaNumeric(corrected);

  if (originalTokens.length !== correctedTokens.length) {
    return false;
  }

  for (let index = 0; index < originalTokens.length; index += 1) {
    if (!isTokenCorrectionLike(originalTokens[index], correctedTokens[index])) {
      return false;
    }
  }

  const changedRatio = ratioOfChangedTokens(originalTokens, correctedTokens);
  return changedRatio <= 0.35;
}

function localCorrectionFallback(input: string): string {
  return cleanTextBasic(input.replace(/\s+([,.;!?])/g, "$1"));
}

export async function normalizeAndFillDefinitions(
  word: string,
  correctDefinition: string,
  entries: DefinitionBatchInput[],
): Promise<DefinitionBatchOutput[]> {
  if (entries.length === 0) {
    return [];
  }

  const fallback = entries.map((entry) => {
    if (!entry.rawDefinition?.trim()) {
      return {
        playerId: entry.playerId,
        correctedText: fallbackAutoDefinition(word, entry.name),
        isAutoGenerated: true,
      };
    }

    return {
      playerId: entry.playerId,
      correctedText: localCorrectionFallback(entry.rawDefinition),
      isAutoGenerated: false,
    };
  });

  try {
    const payload = {
      word,
      correctDefinition,
      players: entries.map((entry) => ({
        playerId: entry.playerId,
        name: entry.name,
        rawDefinition: entry.rawDefinition?.trim() || null,
      })),
    };

    const json = await callGatewayJson<{ definitions: DefinitionBatchOutput[] }>(
      [
        "Tu normalises des définitions de joueurs pour un jeu en français.",
        "Interdiction absolue de reformuler les définitions fournies par les joueurs.",
        "Conserve l'ordre des mots et le choix lexical autant que possible.",
        "Tu peux uniquement corriger: orthographe, accents, apostrophes, espaces, ponctuation, majuscules/minuscules.",
        "Si rawDefinition est null, tu dois inventer une fausse définition plausible (différente de la bonne) et marquer isAutoGenerated=true.",
        "Si rawDefinition n'est pas null: isAutoGenerated=false.",
        "Réponds strictement en JSON: {\"definitions\":[{\"playerId\":string,\"correctedText\":string,\"isAutoGenerated\":boolean}]}",
      ].join(" "),
      JSON.stringify(payload),
    );

    if (!Array.isArray(json.definitions)) {
      return fallback;
    }

    const byPlayerId = new Map<string, DefinitionBatchOutput>();

    for (const item of json.definitions) {
      if (!item || typeof item.playerId !== "string") {
        continue;
      }

      const correctedText = cleanTextBasic(String(item.correctedText ?? ""));
      byPlayerId.set(item.playerId, {
        playerId: item.playerId,
        correctedText,
        isAutoGenerated: Boolean(item.isAutoGenerated),
      });
    }

    return entries.map((entry) => {
      const candidate = byPlayerId.get(entry.playerId);
      if (!candidate || !candidate.correctedText) {
        return fallback.find((f) => f.playerId === entry.playerId) as DefinitionBatchOutput;
      }

      if (!entry.rawDefinition?.trim()) {
        return {
          playerId: entry.playerId,
          correctedText: candidate.correctedText,
          isAutoGenerated: true,
        };
      }

      const safe = keepOriginalOrderAndCount(entry.rawDefinition, candidate.correctedText);
      if (!safe) {
        return {
          playerId: entry.playerId,
          correctedText: localCorrectionFallback(entry.rawDefinition),
          isAutoGenerated: false,
        };
      }

      return {
        playerId: entry.playerId,
        correctedText: candidate.correctedText,
        isAutoGenerated: false,
      };
    });
  } catch {
    return fallback;
  }
}
