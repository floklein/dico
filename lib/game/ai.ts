import {
  cleanTextBasic,
  ratioOfChangedTokens,
  tokenizeAlphaNumeric,
} from "@/lib/game/helpers";

const AI_GATEWAY_URL = "https://ai-gateway.vercel.sh/v1/chat/completions";
const DEFAULT_MODEL = "google/gemini-3-flash";

interface ChatCompletionResponse {
  choices?: Array<{
    message?: {
      content?: string;
    };
  }>;
}

export interface GeneratedRoundWord {
  word: string;
  correctDefinition: string;
}

export interface DefinitionBatchInput {
  playerId: string;
  name: string;
  rawDefinition?: string;
}

export interface DefinitionBatchOutput {
  playerId: string;
  correctedText: string;
  isAutoGenerated: boolean;
}

function getGatewayKey(): string | undefined {
  return process.env.VERCEL_AI_GATEWAY_API_KEY?.trim();
}

function getModelName(): string {
  return process.env.LLM_MODEL?.trim() || DEFAULT_MODEL;
}

function extractJsonText(content: string): string {
  const trimmed = content.trim();
  if (trimmed.startsWith("{")) {
    return trimmed;
  }

  const firstBrace = trimmed.indexOf("{");
  const lastBrace = trimmed.lastIndexOf("}");
  if (firstBrace === -1 || lastBrace === -1 || lastBrace <= firstBrace) {
    throw new Error("Réponse IA non JSON.");
  }

  return trimmed.slice(firstBrace, lastBrace + 1);
}

async function callGatewayJson<T>(
  systemPrompt: string,
  userPrompt: string,
  temperature = 0.2,
): Promise<T> {
  const key = getGatewayKey();
  if (!key) {
    throw new Error("Clé VERCEL_AI_GATEWAY_API_KEY manquante.");
  }

  const response = await fetch(AI_GATEWAY_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${key}`,
    },
    body: JSON.stringify({
      model: getModelName(),
      temperature,
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      response_format: { type: "json_object" },
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Erreur IA (${response.status}): ${errorText}`);
  }

  const body = (await response.json()) as ChatCompletionResponse;
  const content = body.choices?.[0]?.message?.content;
  if (!content) {
    throw new Error("Réponse IA vide.");
  }

  return JSON.parse(extractJsonText(content)) as T;
}

function normalizeCorrectDefinition(input: string): string {
  return cleanTextBasic(input).replace(/[.;:]+\s*$/u, "").trim();
}

export async function generateRoundWord(
  _roundIndex: number,
  excludedWords: string[] = [],
): Promise<GeneratedRoundWord> {
  const excludedPrompt =
    excludedWords.length > 0
      ? `Mots déjà utilisés et interdits: ${excludedWords.join(", ")}.`
      : "";

  const json = await callGatewayJson<{ word: string; correctDefinition: string }>(
    [
      "Tu fournis un mot français difficile et sa bonne définition pour un jeu multijoueur.",
      "Réponds strictement en JSON: {\"word\": string, \"correctDefinition\": string}.",
      "Le mot doit être authentique et peu courant.",
      "La définition doit être naturelle, courte, imparfaite mais crédible, comme un joueur pressé.",
      "Varie les tournures, évite les formulations répétitives et n'utilise pas systématiquement un début par \"On\".",
      "La définition peut être un fragment court, pas forcément une phrase complète.",
      "Interdiction du ton académique et du jargon inutile.",
      "La définition ne doit pas finir par un point final.",
      excludedPrompt,
    ].join(" "),
    "Donne un seul mot difficile inédit et sa définition correcte.",
    0.7,
  );

  const word = cleanTextBasic(String(json.word ?? ""));
  const correctDefinition = normalizeCorrectDefinition(String(json.correctDefinition ?? ""));

  if (!word || !correctDefinition) {
    throw new Error("Sortie IA invalide pour le mot.");
  }

  const excluded = new Set(excludedWords.map((item) => item.toLocaleLowerCase("fr-FR")));
  if (excluded.has(word.toLocaleLowerCase("fr-FR"))) {
    throw new Error(`Mot déjà utilisé renvoyé par l'IA: ${word}.`);
  }

  return { word, correctDefinition };
}

function editDistance(a: string, b: string): number {
  const rows = a.length + 1;
  const cols = b.length + 1;
  const table: number[][] = Array.from({ length: rows }, (_, rowIndex) =>
    Array.from({ length: cols }, (_, colIndex) =>
      rowIndex === 0 ? colIndex : colIndex === 0 ? rowIndex : 0,
    ),
  );

  for (let row = 1; row < rows; row += 1) {
    for (let col = 1; col < cols; col += 1) {
      const cost = a[row - 1] === b[col - 1] ? 0 : 1;
      table[row][col] = Math.min(
        table[row - 1][col] + 1,
        table[row][col - 1] + 1,
        table[row - 1][col - 1] + cost,
      );
    }
  }

  return table[rows - 1][cols - 1];
}

function isTokenCorrectionLike(originalToken: string, correctedToken: string): boolean {
  if (originalToken === correctedToken) {
    return true;
  }

  const distance = editDistance(originalToken, correctedToken);
  const maxAllowed = Math.max(2, Math.floor(originalToken.length * 0.34));
  return distance <= maxAllowed;
}

function keepOriginalOrderAndCount(original: string, corrected: string): boolean {
  const originalTokens = tokenizeAlphaNumeric(original);
  const correctedTokens = tokenizeAlphaNumeric(corrected);

  if (originalTokens.length !== correctedTokens.length) {
    return false;
  }

  for (let index = 0; index < originalTokens.length; index += 1) {
    if (!isTokenCorrectionLike(originalTokens[index], correctedTokens[index])) {
      return false;
    }
  }

  const changedRatio = ratioOfChangedTokens(originalTokens, correctedTokens);
  return changedRatio <= 0.35;
}

export async function normalizeAndFillDefinitions(
  word: string,
  correctDefinition: string,
  entries: DefinitionBatchInput[],
): Promise<DefinitionBatchOutput[]> {
  if (entries.length === 0) {
    return [];
  }

  const payload = {
    word,
    correctDefinition,
    players: entries.map((entry) => ({
      playerId: entry.playerId,
      name: entry.name,
      rawDefinition: entry.rawDefinition?.trim() || null,
    })),
  };

  const json = await callGatewayJson<{ definitions: DefinitionBatchOutput[] }>(
    [
      "Tu normalises des définitions de joueurs pour un jeu en français.",
      "Interdiction absolue de reformuler les définitions fournies par les joueurs.",
      "Conserve l'ordre des mots et le choix lexical autant que possible.",
      "Tu peux uniquement corriger: orthographe, accents, apostrophes, espaces, ponctuation, majuscules/minuscules.",
      "Si rawDefinition est null, invente une fausse définition plausible (différente de la bonne), style joueur pressé: naturel, imparfait, parfois fragment, pas toujours une phrase complète.",
      "Varie les débuts de phrase, évite toute formulation récurrente, n'utilise pas systématiquement des structures commençant par \"On\".",
      "Quand plusieurs joueurs n'ont rien soumis, évite de leur donner des formulations trop proches entre elles.",
      "Si rawDefinition est null: isAutoGenerated=true. Sinon: isAutoGenerated=false.",
      "Réponds strictement en JSON: {\"definitions\":[{\"playerId\":string,\"correctedText\":string,\"isAutoGenerated\":boolean}]}",
    ].join(" "),
    JSON.stringify(payload),
    0.4,
  );

  if (!Array.isArray(json.definitions)) {
    throw new Error("Sortie IA invalide: definitions doit être un tableau.");
  }

  const byPlayerId = new Map<string, DefinitionBatchOutput>();
  for (const item of json.definitions) {
    if (!item || typeof item.playerId !== "string") {
      continue;
    }

    const correctedText = cleanTextBasic(String(item.correctedText ?? ""));
    byPlayerId.set(item.playerId, {
      playerId: item.playerId,
      correctedText,
      isAutoGenerated: Boolean(item.isAutoGenerated),
    });
  }

  return entries.map((entry) => {
    const candidate = byPlayerId.get(entry.playerId);
    if (!candidate || !candidate.correctedText) {
      throw new Error(`Sortie IA incomplète pour le joueur ${entry.playerId}.`);
    }

    if (!entry.rawDefinition?.trim()) {
      return {
        playerId: entry.playerId,
        correctedText: candidate.correctedText,
        isAutoGenerated: true,
      };
    }

    const safe = keepOriginalOrderAndCount(entry.rawDefinition, candidate.correctedText);
    if (!safe) {
      throw new Error(
        `La normalisation IA a reformulé la définition du joueur ${entry.playerId}.`,
      );
    }

    return {
      playerId: entry.playerId,
      correctedText: candidate.correctedText,
      isAutoGenerated: false,
    };
  });
}
